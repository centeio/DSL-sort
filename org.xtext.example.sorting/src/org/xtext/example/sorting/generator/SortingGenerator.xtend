/*
 * generated by Xtext 2.12.0
 */
package org.xtext.example.sorting.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.example.sorting.sorting.*
import java.util.Iterator
import org.eclipse.emf.ecore.EObject
import org.xtext.example.sorting.sorting.Config

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class SortingGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {

//			resource.allContents
//				.filter(Greeting)
//				.map[name]
//				.join(', '))

		fsa.generateFile(resource.className+".PipeStages.java", generatePipeStages(resource.contents.head as Config)); 
		fsa.generateFile(resource.className+resource.allContents.filter(Config).map[name]+".java", generateClass(resource.contents.head as Config)); 
			
		fsa.generateFile(resource.className+".Component.java", 
			'''
			public abstract class Component{
				protected int level = 0;
				public void invoke();
				String call;
				public Port getPort(String name);
				
				public int getLevel() {
					return level;
				}
				public void checkLevel(Component c){
					if(level<c.getLevel())
						level = c.getLevel()+1;
				}
				private int getLevel() {
					return level;
				}
				
			}''');
		 fsa.generateFile(resource.className+".Source.java", 
		 	'''
		 	import java.util.HashMap;
		 	
		 	public abstract class Source extends Component{
		 		protected HashMap<String, Port> outPorts = new HashMap<String, Port>();
		 		Port getPort(String name){return outPorts.get(name);}
		 	}
		 	'''
		 );
		 
		 fsa.generateFile(resource.className+".Filter.java", 
		 	'''
		 	import java.util.HashMap;
		 	
		 	public abstract class Filter extends Component{
		 		protected HashMap<String, Port> inPorts = new HashMap<String, Port>();
		 		protected HashMap<String, Port> outPorts = new HashMap<String, Port>();
		 		public Port getPort(String name){
		 			if(inPorts.get(name) != null) 
		 				return inPorts.get(name);
		 			return outPorts.get(name);
		 		}		
		 	}
		 	'''
		 );
		 fsa.generateFile(resource.className+".Sink.java", 
		 	'''
		import java.util.HashMap;
		 	
		 	public abstract class Sink extends Component{
		 		protected HashMap<String, Port> inPorts = new HashMap<String, Port>();
		 		public Port getPort(String name){
		 			return inPorts.get(name);
		 		}
		 	
			}'''
		 );
		 fsa.generateFile(resource.className+".Port.java", 
		 	'''
		 	import java.util.ArrayList;
		 	
		 	public class Port{
		 		protected Component component;
		 		protected String name;
		 		protected ArrayList<Edge> edges = new ArrayList<Edge>();
		 	
		 		public Port(String name, Component component){
		 			this.name = name;
		 			this.component = component;
		 		}
		 	
		 		public Component getComponent() {
		 			return component;
		 		}
		 	
		 		public void setComponent(Component component) {
		 			this.component = component;
		 		}
		 	
		 		public String getName() {
		 			return name;
		 		}
		 	
		 		public void setName(String name) {
		 			this.name = name;
		 		}
		 	
		 		public ArrayList<Edge> getEdges() {
		 			return edges;
		 		}
		 	
		 		public void setEdges(ArrayList<Edge> edges) {
		 			this.edges = edges;
		 		}
		 		public void addEdge(Edge edge){
		 			this.edges.add(edge);
		 		}
		 	}
		 	'''
		 );
		  fsa.generateFile(resource.className+".Edge.java", 
		 	'''
		 	public class Edge{
		 		protected Port source; // <n1.get(p1),n2.get(p2)> 
		 		protected Port target;
		 	
		 		public Edge(Port source, Port target){
		 			this.source = source;
		 			this.target = target;
		 		}
		 	
		 		public Port getSource() {
		 			return source;
		 		}
		 	
		 		public void setSource(Port source) {
		 			this.source = source;
		 		}
		 	
		 		public Port getTarget() {
		 			return target;
		 		}
		 	
		 		public void setTarget(Port target) {
		 			this.target = target;
		 		}
		 	}
		 	''');
		 	
		 	for(source: resource.allContents.toIterable.filter(Source)){
		 		fsa.generateFile(resource.className+'.'+source.name + ".java",
		 			'''
				public class «source.name» extends Source{
					public «source.name»(String name){
						this.name=name;
						«FOR port : source.outPorts»
							inPorts.put(«port.name», new Port(«port.name»,this));
						«ENDFOR»
					}
					«source.code»
				} ''')}
		 	for(filter: resource.allContents.toIterable.filter(Filter)){
		 		fsa.generateFile(resource.className+'.'+filter.name + ".java",
		 			'''
				public class «filter.name» extends Filter{
					public «filter.name»(String name){
						this.name=name;
						«FOR port : filter.inPorts»
							inPorts.put(«port.name», new Port(«port.name»,this));
						«ENDFOR»
						«FOR port : filter.outPorts»
							outPorts.put(«port.name», new Port(«port.name»,this));
						«ENDFOR»					
					}
					«filter.code»
					
				}''')}
				
		 	for(sink: resource.allContents.toIterable.filter(Sink)){
		 		fsa.generateFile(resource.className+'.'+sink.name + ".java",
		 			'''
				public class «sink.name» extends Sink{
					public «sink.name»(String name){
						this.name=name;
						«FOR port : sink.outPorts»
							outPorts.put(«port.name», new Port(«port.name»,this));
						«ENDFOR»
					}
					«sink.code»
					
				}
		 	'''
		 	);
			fsa.generateFile(resource.className+".Graph.java", generate(resource.contents.head as Config)); 
		 	
		 	}
		 	
		 
		
	}
	
	def CharSequence generateClass(Config config) '''
	'''
	
	def CharSequence generatePipeStages(Config config)'''
		«FOR imp : config.imports»
			import «imp.name»
		«ENDFOR»
		public abstract class PipeStages{
		«FOR par : config.params»
			«par.value»
		«ENDFOR»
		}

	'''
	
	def className(Resource res) {
		var name = res.URI.lastSegment
		return name.substring(0, name.indexOf('.'))
	}
	
	def CharSequence generate(Config config)'''
		«FOR imp : config.imports»
			import «imp.name»
		«ENDFOR»
		import java.util.ArrayList;
		import java.util.HashMap;
		
		
		class Graph {
			private ArrayList<Edge> edges = new ArrayList<Edge>();
			private HashMap<String,Component> nodes = new HashMap<String,Component>();
			
			public void addEdge(Instance from, Port pfrom, Instance to, Port pto){
				Component csource = nodes.get(from);
				Component ctarget = nodes.get(target);
				
				Port source = csource.getPort(pfrom);
				Port target = ctarget.getPort(pto);
				Edge edge = new Edge(source, target);
				edges.put(edge);
				csource.addEdge(edge);
				ctarget.addEdge(edge);
				ctarget.checkLevel(csource);
			}
			
			public static void main(String args[]) {
				«FOR instance : config.instances»
					«instance.component.name» «instance.name» = new «instance.component.name»(«instance.name»);
					nodes.put(«instance.name»);
				«ENDFOR»
				«FOR t : config.transitions»
					addEdge(«t.source»,«t.targetPort»,«t.target»,«t.sourcePort»);
				«ENDFOR»
				
				
			}
		}

		
	'''
}
